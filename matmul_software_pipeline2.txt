#layout: block(shape=[32, 128], size_per_thread=[4, 4], thread_per_warp=[1, 32], warps_per_block=[8, 1])
#layout1: block(shape=[32, 32], size_per_thread=[1, 4], thread_per_warp=[4, 8], warps_per_block=[8, 1])
#layout2: block(shape=[32, 128], size_per_thread=[1, 4], thread_per_warp=[1, 32], warps_per_block=[8, 1])

def matmul(
    a_ptr: float32*,
    b_ptr: float32*,
    c_ptr: float32*
)
    # kind: cuda_tile
    # cuda.block_dim: 256
    # cuda.grid_dim: 256
    let num_n_blocks: int32 = 8
    let pid_m: int32 = (blockIdx.x / num_n_blocks)
    let pid_n: int32 = (blockIdx.x % num_n_blocks)
    let cvt: float32[32, 128, #layout] = create(0.0f, shape=[32, 128], axes=[i, j], layout=#layout)
    let cvt_0: float32*[32, 32, #layout1] = create(((a_ptr + (((pid_m * 32) + i_0) * 1024)) + j_0), shape=[32, 32], axes=[i_0, j_0], layout=#layout1)
    let cvt_1: float32*[32, 128, #layout2] = create(((b_ptr + (i_1 * 1024)) + ((pid_n * 128) + j_1)), shape=[32, 128], axes=[i_1, j_1], layout=#layout2)
    let smem: float32[2, 32, 32, shared(2, 32, 32)] = alloc_tensor(dtype=float32, shape=[2, 32, 32], layout=shared(2, 32, 32))
    let smem_0: float32[2, 32, 128, shared(2, 32, 128)] = alloc_tensor(dtype=float32, shape=[2, 32, 128], layout=shared(2, 32, 128))
    let cvt_2: bool[32, 128, #layout2] = create((i_2 < 1024), shape=[32, 128], axes=[i_2, j_2], layout=#layout2)
    let cvt_3: bool[32, 32, #layout1] = create((j_3 < 1024), shape=[32, 32], axes=[i_3, j_3], layout=#layout1)
    let smem_1: float32[2, 32, 32, shared(2, 32, 32)] = insert_slice_async(cvt_0, smem, 0, cvt_3, axis=0)
    let smem_2: float32[2, 32, 128, shared(2, 32, 128)] = insert_slice_async(cvt_1, smem_0, 0, cvt_2, axis=0)
    async_commit_group()
    let cvt_4: int32[32, 128, #layout2] = create(32768, shape=[32, 128], axes=[i_4, j_4], layout=#layout2)
    let cvt_5: int32[32, 32, #layout1] = create(32, shape=[32, 32], axes=[i_5, j_5], layout=#layout1)
    let cvt_6: float32*[32, 128, #layout2] = add(cvt_1, cvt_4)
    let cvt_7: float32*[32, 32, #layout1] = add(cvt_0, cvt_5)
    async_wait(n=0)
    let ext_slice: float32[32, 32, shared(32, 32)] = extract_slice(smem_1, 0, axis=0, extent=1, layout=shared(32, 32))
    let ext_slice_0: float32[32, 128, shared(32, 128)] = extract_slice(smem_2, 0, axis=0, extent=1, layout=shared(32, 128))
    
    for k in range(32) with c: float32[32, 128, #layout] = cvt, insert_index: int32 = 1, extract_index: int32 = 0, ext_slice_1: float32[32, 32, shared(32, 32)] = ext_slice, ext_slice_2: float32[32, 128, shared(32, 128)] = ext_slice_0, smem_3: float32[2, 32, 32, shared(2, 32, 32)] = smem_1, smem_4: float32[2, 32, 128, shared(2, 32, 128)] = smem_2, cvt_8: float32*[32, 32, #layout1] = cvt_7, cvt_9: float32*[32, 128, #layout2] = cvt_6:
        let cvt_10: float32[32, 32, dot_operand(parent=#layout, id=0)] = convert_layout(ext_slice_1, layout=dot_operand(parent=#layout, id=0), scope=register)
        let cvt_11: float32[32, 128, dot_operand(parent=#layout, id=1)] = convert_layout(ext_slice_2, layout=dot_operand(parent=#layout, id=1), scope=register)
        let c_0: float32[32, 128, #layout] = simt_dot(cvt_10, cvt_11, c)
        let cvt_12: bool[32, 128, #layout2] = create((i_2 < (1024 - (((k + 2) - 1) * 32))), shape=[32, 128], axes=[i_2, j_2], layout=#layout2)
        let cvt_13: bool[32, 32, #layout1] = create((j_3 < (1024 - (((k + 2) - 1) * 32))), shape=[32, 32], axes=[i_3, j_3], layout=#layout1)
        let create: bool[32, 32, #layout1] = create((((k + 2) - 1) < 32), shape=[32, 32], axes=[i_6, j_6], layout=#layout1)
        let logical_and: bool[32, 32, #layout1] = logical_and(cvt_13, create)
        let smem_5: float32[2, 32, 32, shared(2, 32, 32)] = insert_slice_async(cvt_8, smem_3, insert_index, logical_and, axis=0)
        let create_0: bool[32, 128, #layout2] = create((((k + 2) - 1) < 32), shape=[32, 128], axes=[i_7, j_7], layout=#layout2)
        let logical_and_0: bool[32, 128, #layout2] = logical_and(cvt_12, create_0)
        let smem_6: float32[2, 32, 128, shared(2, 32, 128)] = insert_slice_async(cvt_9, smem_4, insert_index, logical_and_0, axis=0)
        async_commit_group()
        let cvt_14: int32[32, 128, #layout2] = create(32768, shape=[32, 128], axes=[i_4, j_4], layout=#layout2)
        let cvt_15: int32[32, 32, #layout1] = create(32, shape=[32, 32], axes=[i_5, j_5], layout=#layout1)
        let cvt_16: float32*[32, 128, #layout2] = add(cvt_9, cvt_14)
        let cvt_17: float32*[32, 32, #layout1] = add(cvt_8, cvt_15)
        async_wait(n=0)
        let ext_slice_3: float32[32, 32, shared(32, 32)] = extract_slice(smem_5, extract_index, axis=0, extent=1, layout=shared(32, 32))
        let ext_slice_4: float32[32, 128, shared(32, 128)] = extract_slice(smem_6, extract_index, axis=0, extent=1, layout=shared(32, 128))
        let insert_index_0: int32 = ((insert_index + 1) % 2)
        let extract_index_0: int32 = ((extract_index + 1) % 2)
        yield c_0, insert_index_0, extract_index_0, ext_slice_3, ext_slice_4, smem_5, smem_6, cvt_17, cvt_16
    get c_1, insert_index_1, extract_index_1, ext_slice_5, ext_slice_6, smem_7, smem_8, cvt_18, cvt_19:
        async_wait(n=0)
        let cvt_20: float32*[32, 128, #layout2] = create(((c_ptr + (((pid_m * 32) + i_8) * 1024)) + ((pid_n * 128) + j_8)), shape=[32, 128], axes=[i_8, j_8], layout=#layout2)
        let cvt_21: float32[32, 128, #layout2] = convert_layout(c_1, layout=#layout2)
        let cvt_22: float32[32, 128, #layout2] = cast(cvt_21, dtype=float32)
        let cvt_23: bool[32, 128, #layout2] = create(((((pid_m * 32) + i_9) < 1024) && (((pid_n * 128) + j_9) < 1024)), shape=[32, 128], axes=[i_9, j_9], layout=#layout2)
        store(cvt_20, cvt_22, cvt_23)

